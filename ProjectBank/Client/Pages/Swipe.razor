@page "/swipe/{keyword}"
@inject HttpClient Http
@using System.Security.Claims
@inject AuthenticationStateProvider AuthenticationStateProvider;
@inject ProjectStateChanged projectChanged;
@inject NotificationService notificationService;

<RadzenNotification/>


<button id="GoBack_btn" onclick="location.href='/browse'">
    <label class="oi oi-arrow-circle-left"></label>
</button>
<button id="info_btn" 
        onclick="window.alert('Swipe Use-guide: \r\n \r\n ' +
         'To Like a project; you must either swipe the project right or click the star. \r\n \r\n ' +
          'To skip a project; you must swipe the project left or click the`X` \r\n \r\n' +
          'To regret/undo a decision; you can click the button in the middle, displayed with a circled arrow.')">i
</button>
@*<input id="slider" type="range" min="1" max="100" value="50" onchange=""/>*@


@if (_projects == null)
{
    <h1>no project to show on keyword: @keyword</h1>
}
else
{
    <div class="outer_box">
        <div class="project_builder" id="p_@_idCounter" style="z-index: @_i;">
            <div class="project_content">
                <div id="project_title">Title: @_currentProject.Title </div>
                <div id="supervisor">by: <x onclick=""> @_currentProject.AuthorName</x></div>
                <br/>
                <hr/>
                <br/>
                <textarea class="project_description" readonly="readonly">@_currentProject.Description</textarea>
                @*<img class="card-img-top" src=@_currentProject.ImageUrl alt = "Project image">*@
                <br/>
                <hr/>
                <br/>
                <textarea class="project_keywords" readonly="readonly">Keywords: @_keywordString</textarea>
            </div>
        </div>
    </div>
    
        <div class="like_and_dislike_btn_div">
            <button id="dislike_btn" @onclick="(() => CheckClick(ClickType.Dislike))">
                <label id="x_icon" class="oi oi-x"></label>
            </button>
            <button id="re-watch_btn" @onclick="(() => CheckClick(ClickType.Rewatch))">
                <label id="re-watch_icon" class="oi oi-action-undo"></label>
            </button>
            <button id="like_btn" @onclick="(() => CheckClick(ClickType.Like))">
                <label id="star_icon" class="oi oi-star"></label>
            </button>
        </div> 
}

@code
{
    [Parameter]
    public string? keyword { get; set; }
    private IKeywordFinder keywordFinder = new KeywordFinder();
    private int _i = 10;
    private int _idCounter = 0;

    private IList<ProjectDetailsDto> _projects;

    private List<int> _likedProjectIds; //This is only used to mimic the database collection of saved projects, st. we dont have to do unnecessary API calls. 

    private ProjectDetailsDto _lastProject;
    private ProjectDetailsDto _currentProject;
    private ClickType _lastClick;
    private ClaimsPrincipal? _user;
    private string? _aToken;
    private string _keywordString;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            if (keyword == "all"){
                await keywordFinder.Setup(Http);
                var project = await Http.GetFromJsonAsync<ProjectDetailsDto>($"/api/Project/1");
                if (project != null)
                {
                    //Tilbage til list
                    _projects = new List<ProjectDetailsDto>();
                    _projects.Append(project);

                    _likedProjectIds = new List<int>();
                    _user = (await AuthenticationStateProvider.GetAuthenticationStateAsync()).User;
                    
                    _aToken = _user.FindFirst(c => c.Type.Contains("aud"))?.Value;
                    
                    _currentProject = project;
                    _keywordString = GetKeyWords();

                }
            } else
            {
                _projects = await Http.GetFromJsonAsync<ProjectDetailsDto[]>($"/api/Keyword/{keyword}"); //all projects containing the specified keyword

                _user = (await AuthenticationStateProvider.GetAuthenticationStateAsync()).User;
                _aToken = _user.FindFirst(c => c.Type.Contains("aud"))?.Value;
                _likedProjectIds = await Http.GetFromJsonAsync<List<int>>($"/api/Account/likedProduct/{_aToken}"); //will return an empty list, if found no saved projects for that user.
                
                if (_projects != null)
                {
                    _currentProject = _projects[0];
                    _keywordString = GetKeyWords();
                    _lastClick = ClickType.Rewatch;
                }
            }
        } catch (AccessTokenNotAvailableException e)
        {
            e.Redirect();
        }
    }

    private enum ClickType
    {
        Like,
        Dislike,
        Rewatch
    }

    private async void CheckClick(ClickType s)
    {
        if (keyword == "all"){
            await CheckClickAll(s);
        }
        else if (s == ClickType.Like) //vi skal lave check på status endpoint kald sender tilbage, så vi kan gøre noget alt efter det. så vi ik bare fortsætter midnless
        {
            if (!_likedProjectIds.Contains(_currentProject.Id))
            {
                await Http.PostAsJsonAsync($"api/Account/{_aToken}", _currentProject.Title); //vil måske gerne lave om til den også får et id
                _likedProjectIds.Add(_currentProject.Id);
                projectChanged.AddSavedProjects(_currentProject.Title);
                ShowNotification("Project added: "+_currentProject.Title,1);
            }
            else
            {
                ShowNotification("You had already liked project: " + _currentProject.Title ,3); 
            }
            if (_idCounter != _projects.Count - 1)
            {
                _idCounter++;
            }
            else
            {
                ShowNotification("No more projects to show. Rewatch to see projects again, or pick a new keyword",2);
            }
            _lastClick = ClickType.Like;
            
        }
        else if (s == ClickType.Rewatch)
        {
            if (_lastClick == ClickType.Like)
            {
                if (_likedProjectIds.Contains(_lastProject.Id))
                {
                    await Http.PutAsJsonAsync($"api/Account/{_aToken}/remove", _lastProject.Title);
                    _likedProjectIds.Remove(_lastProject.Id);
                    projectChanged.RemoveSavedProjects(_lastProject.Title);
                    ShowNotification("Project removed: "+_lastProject.Title, 1);
                }
            }
            if (_idCounter != 0)
            {
                _idCounter--;
            }
            else
            {
                ShowNotification("No projects to rewatch, press like or dislike to scroll through projects", 2);
            }
            _lastClick = ClickType.Rewatch;
        }
        else if (s == ClickType.Dislike)
        {
            if (_likedProjectIds.Contains(_currentProject.Id))
            {
               await Http.PutAsJsonAsync($"api/Account/{_aToken}/remove", _currentProject.Title);
                _likedProjectIds.Remove(_currentProject.Id);
                projectChanged.RemoveSavedProjects(_currentProject.Title);
                ShowNotification("Project removed: " + _currentProject.Title, 1);
            }
            if (_idCounter != _projects.Count - 1)
            {
                _idCounter++;
            }else
            {
                ShowNotification("No more projects to show. Rewatch to see projects again, or pick a new keyword",2);
            }
            _lastClick = ClickType.Dislike;
        }
        
        if (_idCounter != 0)
        {
           _lastProject = _projects[_idCounter - 1]; 
        }
        else
        {
            _lastProject = _projects[0];
        }
        
        _currentProject = _projects[_idCounter % _projects.Count]; //burde ik være nødvendigt med modulo længere

        _keywordString = GetKeyWords();

        await InvokeAsync(StateHasChanged);
    }

    private async Task CheckClickAll(ClickType s){
        switch(s)
        {
            case ClickType.Like:
                if (!_likedProjectIds.Contains(_currentProject.Id))
                {
                    _likedProjectIds.Add(_currentProject.Id);
                    await Http.PostAsJsonAsync($"api/Account/{_aToken}", _currentProject.Title);
                    await UpdateRatios(true);
                }
                //ShowNotification("Project added!");
                _idCounter++;
                _lastProject = _currentProject;
                var nextKeyword = keywordFinder.FindWeightedRandomKeyword();
                var project = await keywordFinder.ReadProjectGivenKeywordAsync(nextKeyword);
                
                if (project != null){
                    _currentProject = project;
                    _projects.Add(_currentProject);
                }
                _lastClick = ClickType.Like;

                break;

            case ClickType.Rewatch:
                //lav metode der ved initialize henter liked projects, så vi kan se om det er nødvendigt med api kald
                
                //_likedProjects.Remove(_currentProject);
                if (_lastClick == ClickType.Like)
                {
                    await Http.PutAsJsonAsync($"api/Account/{_aToken}/remove", _lastProject.Title);
                }

                if (_idCounter != 0) //scuffed?
                {
                    _idCounter--;
                }
                
                _currentProject = _projects.ElementAt(_idCounter % _projects.Count());
                _lastClick = ClickType.Rewatch;
                
                break;

            case ClickType.Dislike:
                //ogs tjek om det nuværende er i liked
                await Http.PutAsJsonAsync($"api/Account/{_aToken}/remove", _currentProject.Title);
                await UpdateRatios(false);

                _idCounter++;
                _lastProject = _currentProject;
                var newKeyword = keywordFinder.FindWeightedRandomKeyword();
                var newProject = await keywordFinder.ReadProjectGivenKeywordAsync(newKeyword);
                
                if (newProject != null){
                    _currentProject = newProject;
                    _projects.Add(_currentProject);
                }
                _lastClick = ClickType.Dislike;


                break;

        }
        
    }

    private async Task UpdateRatios(bool userLikedProject)
    {
        foreach (var keyWordName in _currentProject.Keywords)
        {
            var response = keywordFinder.UpdateRatioAsync(keyWordName, userLikedProject);
            //BØR MAN GØRE NOGET HER I FORHOLD TIL RESPONSE?
        }
    }
    private string GetKeyWords()
    {
        if (_currentProject.Keywords != null) 
        {
            return string.Join(", ", _currentProject.Keywords);
        }

        return "none";
    }
    

    private void ShowNotification(string message, int type)
    {
        var notiMsg = new NotificationMessage();
        
        if (type == 1)
        {
            
            notiMsg = new NotificationMessage {Severity = NotificationSeverity.Success, Summary = "Success", Detail = message, Duration = 2000};
           
        }else if (type == 2)
        {
            
            notiMsg = new NotificationMessage {Severity = NotificationSeverity.Error, Summary = "Error", Detail = message, Duration = 4000};
           
        }else if (type == 3)
        {
            
            notiMsg = new NotificationMessage {Severity = NotificationSeverity.Info, Summary = "Info", Detail = message, Duration = 4000};
           
        }
        
        notificationService.Notify(notiMsg); 
        
    }
}   